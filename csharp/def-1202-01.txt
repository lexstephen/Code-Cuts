<table id="definitionTable">
<tr><td>CH</td><td>Syntax</td><td>Sets of rules for programming laguages such as C#</td></tr>
<tr><td>1-4</td><td>Complier</td><td>Translates instructions which are written in programming laguages into machine-readable format</td></tr>
<tr><td>1-4</td><td>Interpreters</td><td>Check for rule violations line by line. (slower than normal compliers)</td></tr>
<tr><td>1-4</td><td>Assemblers</td><td>Convert the assembly programming language (low level) into machine code </td></tr>
<tr><td>1-4</td><td>Application Software</td><td>Consists of programs developed to perform a specific task. (Games, Search Engines,…)</td></tr>
<tr><td>1-4</td><td>Methodologies</td><td>Used to solve computer related problems</td></tr>
<tr><td>1-4</td><td>Steps in the Development Process</td><td>1- Problem specification - Specifying the problem</td></tr>
<tr><td>1-4</td><td>Steps in the Development Process</td><td>2-Analyze the Problem - Analyze the problem thoroughly- Review the problem Specifications which desribe what the program should accomplish</td></tr>
<tr><td>1-4</td><td>Steps in the Development Process</td><td>3-Design a Solution - Several approaches or methods are used (Procedural and Object- Oriented are most commonly used)</td></tr>
<tr><td>1-4</td><td>Divide-and-Conquer OR Top-down design</td><td>Break the problem into subtasks then conquer each of the subtasks by further decomposing them.</td></tr>
<tr><td>1-4</td><td>Object- Oriented Approach </td><td>Focuses on determining the data characteristics and the methods or behaviors that operate on the data.( Also known as a Class) These characteristics are placed in a class diagram .</td></tr>
<tr><td>1-4</td><td>Steps in the Development Process</td><td>4-Code the Solution - Translate the design into source code</td></tr>
<tr><td>1-4</td><td>Steps in the Development Process</td><td>5-Implement the code - The typed program statements (source code) are complied to check for violations.</td></tr>
<tr><td>1-4</td><td>Steps in the Development Process</td><td>6-Test and Debug - Testing the program to ensure that you get consistent result </td></tr>
<tr><td>1-4</td><td>Steps in the Development Process</td><td>7- Desired Results - The achieving of the final desired product</td></tr>
<tr><td>1-4</td><td>Algorithm</td><td>Is a clear, unambiguous, step-by-step process fro solving a problem</td></tr>
<tr><td>1-4</td><td>Desk Check </td><td>Checking for corectness. ( mimike the computer, in other words you go through the code like a computer and check if its correct)</td></tr>
<tr><td>1-4</td><td>Prototype </td><td>Is a mock-up of screens depicting the look of the final output (design of your final product)</td></tr>
<tr><td>1-4</td><td>Source Code</td><td>Consists of program statements written using a programming language, such as C#</td></tr>
<tr><td>1-4</td><td>Iterative Approach</td><td>This means tha toyu may find it necessary to go back to the design stage to make modifications. ( used in software development process</td></tr>
<tr><td>1-4</td><td>Intermediate Language (IL)</td><td>When rule violations are eliminated , the source code is coverted to Microsoft Intermediate Language. (All languages targeting the .NET platform compile into an IL. (Located between the high-level Source code and the native code)</td></tr>
<tr><td>1-4</td><td>Native code</td><td>Is the machine language code of a particular computer</td></tr>
<tr><td>1-4</td><td>Common Language Runtime (CLR)</td><td>Loads predefined .NET classes used by the program into the memory and then performs a second compile</td></tr>
<tr><td>1-4</td><td>Just-In-Time (JIT)</td><td>Is a complier which transforms the IL code to platform's native code</td></tr>
<tr><td>1-4</td><td>Test Driven Development (TDD)</td><td>Is a programming methodology that emphasizes fast, incremental development and writing tests before writing code.</td></tr>
<tr><td>1-4</td><td>Logic Errors</td><td>Might cause an abnormal termination of the program or just produce incorrect results.</td></tr>
<tr><td>1-4</td><td>Run-time error</td><td>Normally causes program crashes (stops executing) and the reporting of error messages</td></tr>
<tr><td>1-4</td><td>Programming Methodologies</td><td>A strategy or a set of directions</td></tr>
<tr><td>1-4</td><td>Structured Procedural Programming</td><td>Is process oriented focusing on the processes that data undergoes from input untill meaningful output is produced.</td></tr>
<tr><td>1-4</td><td>FORTAN</td><td>Formula Translator</td></tr>
<tr><td>1-4</td><td>COBOL</td><td>Bommon Business Oriented Language</td></tr>
<tr><td>1-4</td><td>.NET</td><td>Is an environment in which programs run and was designed to be a new programming paradigm. It is not an operating system, but rather a layer between the operating system and other applications. It provides a platform for developing and running code that is easy to use.</td></tr>
<tr><td>1-4</td><td>\n</td><td>Cursor advances to the next line; similar to pressing the Enter Key</td></tr>
<tr><td>1-4</td><td>\t</td><td>Cursor advances to the next horizontal tab stop</td></tr>
<tr><td>1-4</td><td>\"</td><td>Double Quote is printed</td></tr>
<tr><td>1-4</td><td>\'</td><td>Single quote is printed</td></tr>
<tr><td>1-4</td><td>\\ </td><td>Backslash is printed</td></tr>
<tr><td>1-4</td><td>\r</td><td>Cursor advances to the beginning of the current line</td></tr>
<tr><td>1-4</td><td>\a</td><td>Alert signal (short beep) is sounded</td></tr>
<tr><td>1-4</td><td>ASCII</td><td>American Standard Code for Information Interchange</td></tr>
<tr><td>1-4</td><td>Identifiers</td><td>are names of elements that appear in a program, such as data items</td></tr>
<tr><td>1-4</td><td>Keywords</td><td>are predefined reserved identifiers that have special meanings to the complier. They cannot be used as Identifiers in your program</td></tr>
<tr><td>1-4</td><td>Pascal Case</td><td>the first letter in the identifier and the first letter of each subsequent concatenated word are capitalized.</td></tr>
<tr><td>1-4</td><td>Camel Case</td><td>the first letter in the identifier is lowercase and the first letter of each subsequent concatenated word are capitalized.</td></tr>
<tr><td>1-4</td><td>Variable </td><td>Represents an area in the computer where a value of a particular data type can be stored. When you declare a variable you allocate memory for that data item, in your program.</td></tr>
<tr><td>1-4</td><td>Literals</td><td>Are the numbers,characters and combinations of characters used in your program. They can be assigned to a variable or used in an expression.</td></tr>
<tr><td>1-4</td><td>Instantiating</td><td>This happens every time you declare a variable </td></tr>
<tr><td>1-4</td><td>Const</td><td>When you add the keyword "Const" to a declaration it becomes a constant.</td></tr>
<tr><td>1-4</td><td>=</td><td>assignment operator</td></tr>
<tr><td>1-4</td><td>+</td><td>Overloaded operator</td></tr>
<tr><td>1-4</td><td>Compound Operators</td><td>Provide a shortcut way to write assignment statements using the result as a part of the computation. (ans += 5)</td></tr>
<tr><td>1-4</td><td>Chapter 3</td><td></td></tr>
<tr><td>1-4</td><td>Heading</td><td>is the first line of a method</td></tr>
<tr><td>1-4</td><td>Modifiers - public</td><td>No restrictions</td></tr>
<tr><td>1-4</td><td>Modifiers - protected </td><td>Limited to the containing class or classes derived from the containing class </td></tr>
<tr><td>1-4</td><td>Modifiers - internal</td><td>Limited to current project</td></tr>
<tr><td>1-4</td><td>Modifiers - protected internal</td><td>Limited to current project or classes derived from class</td></tr>
<tr><td>1-4</td><td>Modifiers - private</td><td>Limited to containing class</td></tr>
<tr><td>1-4</td><td>desk check </td><td>use sample data to verify algorithms by mimicking the computer </td></tr>
<tr><td>1-4</td><td>prototype </td><td>a mock-up of screens depicting the look of the final output.</td></tr>
<tr><td>1-4</td><td>pseudocode</td><td>steps are written in pseudo or approximate code format, which looks like English statements.</td></tr>
<tr><td>1-4</td><td>Instantiate</td><td>you instantiate a blueprint by building a house using its template. Many objects of a particular class can be instantiated. Thus, an object is an instance of the class </td></tr>
<tr><td>1-4</td><td>Construction</td><td>When data members are associated with the class, an object is created or constructed. </td></tr>
<tr><td>1-4</td><td>Inheritance</td><td>It is possible to define sub classes of data objects that share some or all of the parent's class characteristics. This is what enables reuse of code. </td></tr>
<tr><td>1-4</td><td>Method</td><td>collection of one or more statements combined to perform an action. The heading for the method contains its signature, which includes the name of the method and its argument list. Return types and modifiers, such as public and static, are part of the heading, but not considered part of the signature. The heading line for the Main( ) method begins with the keyword static, which implies that a single copy of the method is created, and that you can access this method without having an object of the class available. </td></tr>
<tr><td>1-4</td><td>Polymorphism</td><td>Through polymorphism, you are able to invoke methods of the same name on objects of different classes and have the correct method executed. For example, you might have sub classes of UndergraduateStudent and GraduateStudent. They could both inherit characteristics from the Student class. Both of the sub classes might have their own method that contains details about how to determine their cost of tuition. Both sub classes might name their method DetermineTuitionCosts( ). Through polymorphism, the correct method is executed based on which object invoked it. </td></tr>
<tr><td>1-4</td><td>Void</td><td>If a method does not return a value, the void keyword is included to signal that no value is returned. When the method does return a value, the type of value is included as part of the heading. </td></tr>
<tr><td>1-4</td><td>Keywords </td><td>Predefined, reserved identifiers that have special meanings to the compiler.</td></tr>
<tr><td>1-4</td><td>Contextual keywords </td><td>only have special meaning when used in a specific context.</td></tr>
<tr><td>1-4</td><td>Object </td><td>an instance of a class. It is an occurrence of the class. </td></tr>
<tr><td>1-4</td><td>Value and reference types </td><td>Value types are often called the fundamental data types or primitive data types of the language. Struct types (Numeric [Integral | Floating Point | Decimal]| Bool | Struct)| Enumerated types; char, and string. </td></tr>
<tr><td>1-4</td><td>Pointer</td><td>a variable that holds the memory address of another type</td></tr>
<tr><td>1-4</td><td>Decimal</td><td>If you attempt to initialize a decimal variable and forget to use the M or m suffix, a compiler error is generated</td></tr>
<tr><td>1-4</td><td>Object Oriented</td><td>With object-oriented analysis, design, and programming, the focus is on determining the objects you want to manipulate rather than the processes or logic required to manipulate the data. Remember that the procedural approach focuses on processes. One of the underlying assumptions of the object-oriented methodology is that the world contains a number of entities that can be identified and described. An entity is often defined as a person, place, or thing. It is normally a noun. By abstracting out the attributes(data) and the behaviors (processes on the data), you can divide complex phenomena into understandable entities. An abstraction is simply a description of the essential, relevant properties of an entity. </td></tr>
<tr><td>1-4</td><td>Encapsulation</td><td>Using the object oriented methodology, data attributes and actions (or characteristics and behaviors) are encapsulated, which means that they are combined together to form a class. </td></tr>
<tr><td>1-4</td><td>Value types </td><td>contain their own copy of data in binary notation. The data is stored in the actual memory cell that is addressed by the value type's identifier: int, uint, long, ulong, short, ushort, float (7 digits 32-bit), double (15-16 digits 64-bit)</td></tr>
<tr><td>1-4</td><td>Reference types</td><td>All types that are not value types are reference types, the contents of these memory cells are much different. Reference types contain the address or location in which the sequence of bits is stored. </td></tr>
<tr><td>1-4</td><td>type / range / width in bits</td><td>byte 0 to 255 8-bit</td></tr>
<tr><td>1-4</td><td>type / range / width in bits</td><td>sbyte -128 to 127 8-bit</td></tr>
<tr><td>1-4</td><td>type / range / width in bits</td><td>char U+0000 to U+ffff 16-bit</td></tr>
<tr><td>1-4</td><td>type / range / width in bits</td><td>int -2, 147, 483, 648 to 2, 147, 483, 647 32-bit</td></tr>
<tr><td>1-4</td><td>type / range / width in bits</td><td>uint 0 to 4, 294, 967, 295 32-bit</td></tr>
<tr><td>1-4</td><td>type / range / width in bits</td><td>long -9, 223, 372, 036, 854, 775, 808 to 9, 223, 372, 036, 854, 775, 807 64-bit</td></tr>
<tr><td>1-4</td><td>type / range / width in bits</td><td>ulong 0 to 18, 446, 744, 073, 709, 551, 615 64-bit</td></tr>
<tr><td>1-4</td><td>type / range / width in bits</td><td>short -32, 768 to 32, 767 16-bit</td></tr>
<tr><td>1-4</td><td>type / range / width in bits</td><td>ushort 0 to 65, 535 16-bit</td></tr>
<tr><td>1-4</td><td>format specifier</td><td>C or c Currency Number; converted to a string that Represents a currency amount with dollar symbols, decimal, and commas. If present, the precision modifier indicates the number of decimal places. ("{0:C3}", 4238.8) - produces $4, 238.800</td></tr>
<tr><td>1-4</td><td>format specifier</td><td>D or d Decimal Number; converted to a string of integer digits (0-9), prefixed by a minus sign if the number is negative. If required, the number is padded with zeros to its left to produce the number of digits requested in the specifier. ("{0:D5}", 42) - produces 00042</td></tr>
<tr><td>1-4</td><td>format specifier</td><td>{0:E2} or e Scientific (exponent) - produces 4.24E+003 </td></tr>
<tr><td>1-4</td><td>format specifier</td><td>{0:F2} or f Fixed point - produces 4238.80 </td></tr>
<tr><td>1-4</td><td>format specifier</td><td>{0:G} or g General Number - most compact of either fixed-point or scientific notation, depending on the type of the number and whether a precision specifier is present.</td></tr>
<tr><td>1-4</td><td>format specifier</td><td>{0:N2} or n Number - produces 4, 238.80</td></tr>
<tr><td>1-4</td><td>format specifier</td><td>{0:P} or p Percent - produces 12.30 %</td></tr>
<tr><td>1-4</td><td>Method</td><td>a group of statements placed together under a single name, defined inside a class. Methods are the members of a class that perform an action, and through writing methods you describe the behavior of data.</td></tr>
<tr><td>1-4</td><td>Class </td><td>a collection of data and methods. </td></tr>
<tr><td>1-4</td><td>Heading</td><td>first line of a method, includes modifiers (ie public static), return type (ie void ), name (ie Main) and parameters or arguments enclosed within brackets</td></tr>
<tr><td>1-4</td><td>Modifier</td><td>added to a type or a type member's declaration to change or alter it or to indicate how it can be accessed.</td></tr>
<tr><td>1-4</td><td>Static modifier </td><td>Static is used in this context to indicate that a method belongs to the type itself rather than to a specific object of a class. This means that it is not necessary to instantiate an object of the class to use the method member.</td></tr>
<tr><td>1-4</td><td>Calling a static method</td><td>If a member method is in the same class that includes a static method, the static method can be called by typing its identifier (without an object or class name). However, if you are calling a static method from another class, the class name must be used with the method name. For example, to call theSqrt( )method of the Math class, you would write: double answer = Math.Sqrt(25);</td></tr>
<tr><td>1-4</td><td>Class Methods</td><td>Methods that use the static modifier</td></tr>
<tr><td>1-4</td><td>Access modifier</td><td>Specifies the level of accessibility for types and their members - includes public, private, protected, internal, protected internal</td></tr>
<tr><td>1-4</td><td>Private members</td><td>Accessible only within the body of the class in which they are declared. Often in object-oriented design, data is defined with a private modifier and methods that access the data are declared to have public access. By defining the data members as private, you restrict access to the data through the members' methods or properties. When a class or a class member does not specify a modifier, the default accessibility level of private is assumed</td></tr>
<tr><td>1-4</td><td>Method Arguments</td><td>Formal parameters, or arguments, appear in the heading of a method. Actual arguments, or parameters, appear in the call. Think of the actual argument as being the actual data that is sent to the method. The formal parameters are like placeholders; they formally indicate what type of data is expected to be sent for the method to use. </td></tr>
<tr><td>1-4</td><td>Predefined classes</td><td>includes Read, ReadLine, Write, WriteLine, Parse, Math</td></tr>
<tr><td>1-4</td><td>Abs </td><td>returns the absolute value of a specified number; overloaded—can be used with int, double, decimal, short, float, sbyte, and long. Math.Abs(-88.62) returns the value 88.62; public static int Abs(int)</td></tr>
<tr><td>1-4</td><td>Ceiling</td><td>returns the smallest whole number greater than or equal to the specified number. Math.Ceiling(88.12) returns the value 89; public static double Ceiling</td></tr>
<tr><td>1-4</td><td>Cos </td><td>returns the cosine of the specified angle measured in radians; public static double Cos(double)</td></tr>
<tr><td>1-4</td><td>Exp </td><td>returns e raised to the specified power. e is defined as a constant in the Math class. It has a value of 2.7182818284590452354. Example: Math.Exp(2) returns the value 7.38905609893065; public static double Exp(double)</td></tr>
<tr><td>1-4</td><td>Floor </td><td>returns the largest whole number less than or equal to the specified number. Example: Math.Floor(88.62) returns the value 88; public static double Floor (double)</td></tr>
<tr><td>1-4</td><td>Log </td><td>returns the logarithm of a specified number. Two overloaded methods. The first one returns the natural (base e) logarithm of a specified number. It takes a single argument of type double. The second one (signature to the right) returns the logarithm of a specified number. Example: Math.Log(4) returns the value 1.38629436111989; public static double Log (double, double)</td></tr>
<tr><td>1-4</td><td>Max </td><td>returns the larger of two specified numbers; overloaded with 11 different methods (byte, decimal, double, short, int, long, sbyte, float, ushort, uint, and ulong). All require the same type for both arguments. Example: Math.Max(87, 13) return s 87; public static double Max (double, double)</td></tr>
<tr><td>1-4</td><td>Min </td><td>returns the smaller of two numbers. Overloaded—exactly like Max in the previous row. Example: Math.Min(87, 13) return s 13; public static intMin(int, int)</td></tr>
<tr><td>1-4</td><td>Pow</td><td>returns a specified number raised to the specified power. Not overloaded. Arguments can be entered as int. They are implicitly converted. return value must be stored in double ; otherwise, you receive a syntax error. Example: Math.Pow(5, 3) return s 125; public static double Pow(double, double)</td></tr>
<tr><td>1-4</td><td>Round </td><td>returns the number nearest the specified value. Overloaded. Can return a number with the specified precision indicated by the second argument, as illustrated with the signature to the right. Example: Math.Round(87.982276, 4) return s 87.9823; public static double Round(double, int)</td></tr>
<tr><td>1-4</td><td>Sign </td><td>returns a value indicating the sign of a number (-1 for negative values; 1 for positive; 0 for zero values). Overloaded—each return s an int. Argument can be used with double, decimal, long, short, sbyte, int, or float . Example: Math.Sign(46.3) return s 1; public static intSign(double)</td></tr>
<tr><td>1-4</td><td>Sin </td><td>returns the sine of the specified angle measured in radians; public static double Sin(double)</td></tr>
<tr><td>1-4</td><td>Sqrt </td><td>returns the square root of a specified number. return value must be stored in double ; otherwise, you receive a syntax error. Example: Math.Sqrt(25) return s 5; public static double Sqrt(double)</td></tr>
<tr><td>1-4</td><td>Tan </td><td>returns the tangent of the specified angle measured in radians; public static double Tan(double)</td></tr>
<tr><td>1-4</td><td>User-defined methods </td><td>classified into two categories: methods that do not return a value, called void methods; methods that do return a value, called value- returning methods; all user-defined classes inherit four methods (ToString( ), Equals( ), GetType( ), and GetHashCode( )) from the object class.</td></tr>
<tr><td>1-4</td><td>Void methods </td><td>used to print instructions or other output, do not do any input/return values. To call these nonvalue-returning methods, simply enter the method's identifier followed by a set of parentheses. If the method has parameters, the call will include actual arguments inside the parentheses. These methods are class methods; they include the static keyword in the heading: DisplayInstructions( ); DisplayResults(16.5, 18.95); </td></tr>
<tr><td>1-4</td><td>Calling a void method</td><td>A call to the method that does not return a value uses the following syntax: [qualifier].MethodName(argumentList); - A qualifier is added to the preceding syntax notation to indicate that it might be necessary to include a class or object identifier. Calls to the WriteLine( ) method have included the Console class as the qualifier.</td></tr>
<tr><td>1-4</td><td>Value-returning Method </td><td>Every method that has a return type other than void must have a return statement in the body. A compatible value of the type found in the heading follows the return keyword. This return does not actually have to appear as the last statement; however, it is good practice to design your methods so they have one entry and one exit. </td></tr>
<tr><td>1-4</td><td>Local variable </td><td>exists only inside the method where it is declared. This method is the only place these three variables can be referenced. The term visible is often used to indicate where an identifier has meaning and can be used. A variable's life begins with its declaration in a method and ends when it exits the method. Scope is very similar to visibility in that it is used to describe where in the program's text the identifier can be used. Thus, the variable's scope covers the location where it is declared, to the closing curly brace of the method. </td></tr>
<tr><td>1-4</td><td>Scope of an identifier</td><td>the region of the program in which that identifier is usable. Scope applies to methods as well as variables. </td></tr>
<tr><td>1-4</td><td>Types of Parameters </td><td>Call by value is the default type. With call by value, a copy of the original value is made and stored in a separate, different memory location. If the method changes the contents of the variable sent to it, this does not affect the original value stored in the variable from the calling method. The original value is retained when control passes back to the calling method. There are three other types of parameters: ref; out; and params.</td></tr>
<tr><td>1-4</td><td>Ref and out </td><td>cause a method to refer to the same variable that was passed into the method. Instead of making a copy of the original value and storing the copied value in a different memory location, as happens when you send in a value parameter, when you use ref or out the method gains access to the original memory location. Any changes made to the data in the method are reflected in that variable when control passes back to the calling method. With call by reference, you send the address of the argument to the method. You must include either ref or out in both the call and in the method's heading parameter list. They must match. In other words, you cannot use ref in the heading and out in the call. A call must also include the keyword. The keywords differ in that the ref keyword cannot be used unless the original argument is initialized before it is sent to the method. This restriction does not exist for out. The out keyword is useful for methods that allow users to enter the variable's value in a method, and have those values available back in the calling method when control returns.</td></tr>
<tr><td>1-4</td><td>Default Values with Optional Parameters</td><td>When you assign a default value to a parameter, it then becomes an optional parameter. You do not have to send in a value every time you call the method. Instead the default value is used if no value is sent in as a parameter. You may have more than one optional parameter associated with a method. However, if you have more than one, the optional parameters must be placed last in the list of parameters, after any required parameters</td></tr>
<tr><td>1-4</td><td>Named arguments </td><td>free you from the need to remember or to look up the order of parameters for the method call. The parameter for each argument can be specified using the parameter's name followed by a colon ( : ) and then the assigned argument's value. Naming parameters also has the added feature that you can send the arguments into the method in any order. firstName: "Sue"'</td></tr>
<tr><td>1-4</td><td>Constructors </td><td>Special types of methods used to create objects. Object-oriented design of applications facilitates reuse of code. After the class is defined, you create instances, or examples, of the class. This is called instantiating the class. An instance of a class is called an object. When you instantiate the class, you actually create an instance of the class, an object that takes up space and exists. It is through this special type of method, called a constructor, that you create instances of a class. Constructors differ from other methods in two ways: constructors do not return a value, but the keyword void is not included. Constructors use the same identifier (name) as the class name. Constructors are methods. Like other methods, they can be overloaded. A public access modifier is always associated with constructors so that other classes can instantiate objects of their type. When you write a class, a constructor is automatically created for you if you do not explicitly define one. This one is called the default constructor . It has no functionality, other than the fact that it can be used to create an instance of the class. Default values are assigned to each member data field if the default constructor is used to create an object of the class type. No parameters are included with the default constructor . It has no body, simply opening and closing curly braces. Constructors are used to provide initial values for the object's data members. </td></tr>
<tr><td>1-4</td><td>Instance method </td><td>members of a class can directly access private data members of the same class; can be manipulated. ie in public double CalculateAverage( ) { return (score1 + score2 + score3) / 3.0; }, CalculateAverage( )can directly accessscore1, score2, and score3. It was not necessary to send that data into the method via a parameter.</td></tr>
<tr><td>1-4</td><td>Property</td><td>One of the underlying themes of object -oriented programming is encapsulation, which states that the internal representation of an object is generally hidden, thus member data are defined with private access. Typically, the only way to access, inspect, or manipulate the object's data is through the object's public methods. Another option is to define and use properties; which look like a data field, but does not directly represent a storage location. Properties are more closely aligned to methods. They provide a way to change or retrieve private member data. When you define a property either the get or the set, do not always need both. </td></tr>
<tr><td>1-4</td><td>Mutator/Set</td><td>To change the current state or value of an object member's data, special methods called mutators can be used. Mutators are sometimes called setters. A mutator is normally written to include one parameter that represents the new value a data member should have. Like accessors, mutators are needed because of the private accessibility of instance variables. Mutator method's return type is void. After the set property for a variable is defined, you can change the private instance variables data using that property in any class that instantiates an object. For example, if an instantiated object is named berber, to change the pricePerSqYard you could write: berber.PricePerSqYard = 25.99. </td></tr>
<tr><td>1-4</td><td>Set:Value </td><td>The set portion of the property uses an implicit parameter, called value. The type of value is always the same as the private member that is being associated with the property.</td></tr>
<tr><td>1-4</td><td>Contextual keywords </td><td>get, set, and value are not regular keywords, however, it is not necessary to declare value, get, or set. They have special meaning when used with properties. They are contextual keywords. No parentheses or parameter is placed after the property identifier. ie: public double Price { get { return pricePerSqYard;} set {pricePerSqYard =value;} }</td></tr>
<tr><td>1-4</td><td>Inheritance</td><td>In C#, the very top level class (like your great, great, great...grandparent) is called object. C# supports only single inheritance. As opposed to getting characteristics from two separate parents, in C# you only get one parent class, but that parent class can also have a parent class. At the very top of this hierarchy is object. When you design your own classes, you can make use of these methods inherited from object by calling them or you can override them and give new definitions for one or more of the methods.</td></tr>
<tr><td>1-4</td><td>Object's ToString( ) method </td><td>called automatically by several methods, including the Write( )and WriteLine( ) methods, can be invoked directly, returns a human readable string. Numeric data types such as int, double, float, and decimal data types have overloaded ToString( ) methods. One of their ToString( )signatures enables you to send as an argument a format specifier. </td></tr>
<tr><td>1-4</td><td>Accessor/Get</td><td>To read the current state or value of an object member's data, accessors can be used. Accessors are also referred to as getters. They send back the value of a data member, without changing it. Accessors are used because instance variables, data members of a class, are normally defined using a private modifier. Objects that are instance s of one class might need to access members of another class. They do this through calling methods. Because methods are usually defined as public, this communication is possible. An accessor normally returns just the current value of a data member so that the current value can be used by other classes. The body of the get must return a value of the property type. If you include only the get, the property is considered a read-only property because the value of the instance variable cannot be changed through the property. The execution of the get is equivalent to reading the value of the field.</td></tr>
<tr><td>1-4</td><td>Calling instance Methods </td><td>Instance methods are nonstatic methods. When defined, do not use the static keyword, when invoked do not use the class name. Recall methods in the Math class are class methods. In order to invoke thePow( ) method for example, you had to precede the methods name with the class name (Math.Pow( )). A class method, static method, belongs to the whole class. You must use the class name to call it. Instance methods belong to specific objects. You must call or invoke them with an object. After a class template has been defined to include private member data, public methods, and public properties, many different applications can use the class. To do so, objects of the class are instantiated using the class constructor.</td></tr>
<tr><td>1-4</td><td>Calling Accessor and Mutator Methods</td><td>Accessor and mutators are instance methods. All instance methods are called in exactly the same manner as class methods, with one exception. If the method is being called from another class that has instantiated an object of the class, the method name is preceded by the object name. If another member of the same class is using the method, all that is needed is the name of the method. You never precede an instance method with the name of the class like you do with static class methods. In order to call the method in another class, a specific object must be associated with it. </td></tr>
<tr><td>5</td><td>Basic programming constructs</td><td>Simple sequence, selection, iteration/loop statements</td></tr>
<tr><td>5</td><td>Simple sequence</td><td>Once execution begins, it continues in a linear fashion until the end of the program; can be altered by calling methods</td></tr>
<tr><td>5</td><td>Selection Statement</td><td>Used for decision making and allows a program statement to deviate from the sequential path</td></tr>
<tr><td>5</td><td>Iteration</td><td>Enables you to write instructions that can be repeated</td></tr>
<tr><td>5</td><td>Conditional expressions</td><td>Produce a Boolean result, true or false</td></tr>
<tr><td>5</td><td>Test Condition</td><td>aka Conditional expression; a relational test made between two operands</td></tr>
<tr><td>5</td><td>Overloaded operators</td><td>Defined to perform different based on their operands; in addition to being defined for numeric data types, == and != are defined for strings in C#; strings are compared letter by letter against each other</td></tr>
<tr><td>5</td><td>Relational operators</td><td>Allow you to test variables to see if one is greater or less than another variable or value</td></tr>
<tr><td>5</td><td>Comparison operator</td><td>#ERROR!</td></tr>
<tr><td>5</td><td>Logical operator</td><td>&, &&, |, ||, ! - combined with logical conditional operators to form complex expressions; operands to logical operators must be Boolean</td></tr>
<tr><td>5</td><td>Conditional Logical Operator</td><td>&& ||</td></tr>
<tr><td>5</td><td>Logical negation operator</td><td>A unary operator that negates its operand and is called the NOT operator</td></tr>
<tr><td>5</td><td>Short-circuiting Logical Operator</td><td>&& || as soon as the value of the entire expression is known, evaluation stops. Ie. If the first half of a conditional expression evaluates to false, the second will not be parsed - single operators & | do not short circuit</td></tr>
<tr><td>5</td><td>If Selection Statement</td><td>Classified as one-way, two-way or nested, used in combination with a conditional expression; facilitates specifying alternate paths based on the result of the conditional expression</td></tr>
<tr><td>5</td><td>One-way Selection Statement</td><td>Used when an expression needs to be tested; if true, an action is performed</td></tr>
<tr><td>5</td><td>Two-way If Statement</td><td>an optional clause is added to an if statement to define behavior for when an expression evaluates as false; true or false command is executed in a 2-way If Statement, but not both</td></tr>
<tr><td>5</td><td>TryParse() Method</td><td>Test the value prior to doing the conversion to prevent having an exception thrown; converts the string representation of a value to its equivalent value of a different type; returns a Boolean indicating whether it was successful</td></tr>
<tr><td>5</td><td>Out Parameter</td><td>Output-only parameters; no value in result when the method is invoked; parameter is considered initially unassigned; must appear as part of the heading for the method and also in the call to the method</td></tr>
<tr><td>5</td><td>Nested if.. else statement</td><td>used to test multiple expressions</td></tr>
<tr><td>5</td><td>Decision tree</td><td>a design tool that allows you to represent complex procedures visually; nodes are used to represent decision points and lined branch out from the nodes to represent either further conditions or, eventually, the action to be taken based on the conditions expressed to the left</td></tr>
<tr><td>5</td><td>Lining Up</td><td>aka Matching; the rule that an else goes with the closest previous if that does not have its own else</td></tr>
<tr><td>5</td><td>Switch Statement</td><td>Considered a multiple selection structure; also known as Case Statement; allows you to perform a large number of alternatives based on the value of a single variable; must evaluate to an integral or string value (cannot be used with double, decimal or float)</td></tr>
<tr><td>5</td><td>Jump Statement ?</td><td>Considered a multiple selection structure; also known as Case Statement; allows you to perform a large number of alternatives based on the value of a single variable; must evaluate to an integral or string value (cannot be used with double, decimal or float)</td></tr>
<tr><td>5</td><td>Ternary Operator</td><td>aka Conditional Operator; a single-line if..else statement consisting of a question mark and a colon ie expression1?expression2:expression3; where expression2= what to do if 1 is true and expression3= what to do if 1 was false</td></tr>
<tr><td>5</td><td>Left associative operations</td><td>are performed from left to right (all binary operators)</td></tr>
<tr><td>5</td><td>Right associative</td><td>operations are performed from right to left (assignment operators, conditional operator)</td></tr>
<tr><td>6</td><td>Empty bodied loop</td><td>Created when an errant semicolon is placed in an iteration structure</td></tr>
<tr><td>6</td><td>Infinite loop</td><td>One with no provisions for termination</td></tr>
<tr><td>6</td><td>Pretest loop</td><td>One, such as while, in which the conditional expression is tested before any of the statements in the body of the loop are performed</td></tr>
<tr><td>6</td><td>Counter controlled loop</td><td>A variable simulating a counter is used as the loop control variable</td></tr>
<tr><td>6</td><td>Off by one error</td><td>Happens when a loop is set to <10 when they mean <= 10, for example</td></tr>
<tr><td>6</td><td>Sentinel controlled loop</td><td>Used when it is not known during development how many iterations are required; also known as an indefinite loop; requires user to enter a predetermined value to exit</td></tr>
<tr><td>6</td><td>Sentinel value</td><td>An extreme/"dummy" value entered to break a loop</td></tr>
<tr><td>6</td><td>Prime the Read</td><td>Input a value prior to using it in a loop</td></tr>
<tr><td>6</td><td>Event-driven model</td><td>in Windows applications, manages the interaction between the user and the GUI by handling repetition for you</td></tr>
<tr><td>6</td><td>MessageBox()</td><td>Predefined C# class used to display info to users through its Show() method member; use MessageBox.Show(); requires a reference to System.Windows.Forms.dll assembly and "using System.Windows.Forms;"</td></tr>
<tr><td>6</td><td>MessageBox buttons</td><td>AbortRetryIgnore; OK; OKCancel; RetryCancel; YesNo; YesNoCancel</td></tr>
<tr><td>6</td><td>MessageBox icons</td><td>Asterisk; Error; Exclamation; Hand; Information; None; Question; Stop; Warning</td></tr>
<tr><td>6</td><td>State Controlled Loops</td><td>aka Flag Controlled loops; after initializing a value to a variable, remain unchanged until it is time for the loops to stop running; often used with Boolean</td></tr>
<tr><td>6</td><td>For Statement</td><td>Associated with counter controlled types of loops primarily</td></tr>
<tr><td>6</td><td>Automatic Garbage Collection</td><td>If a variable is declared inside a block, it ‘dies' outside the block and its space is released back to the operating system for reuse</td></tr>
<tr><td>6</td><td>Foreach Statement</td><td>Used to iterated through a collection such as an array</td></tr>
<tr><td>6</td><td>Array</td><td>A data structure that allows multiple values to be stored under a single identifier</td></tr>
<tr><td>6</td><td>Do.. While Structure</td><td>The only post-test structure available in C#; statements are executed once before the conditional expression is tested</td></tr>
<tr><td>6</td><td>Recursive Calls</td><td>A technique used where a method calls itself repeatedly until it arrives at the solution; similar to circular definition in that the recursive method contains a call to itself</td></tr>
<tr><td>6</td><td>Base Case</td><td>A simple, direct answer that is arrived at without another call to the method; the simplest form of the solution</td></tr>
<tr><td>6</td><td>System Stack</td><td>Used to store values in a recursive solution; analogous to a stack of books - as each recursive call is returned, the old variables are removed from the stack and used in a Last In/First Out (LIFO) approach</td></tr>
<tr><td>6</td><td>Unconditional Transfer of Control</td><td>When a command such as break is used in a loop to immediately transfer out of it</td></tr>
<tr><td>6</td><td>Continue</td><td>Like break, a form of jump statement. When continue is reached, a new iteration of the nearest enclosing while, do.. while, for, or foreach statement is started. When continue is reached in a loop, the rest of that loop is not performed; Difference between break and continue is that the continue statement does not stop the execution of the loop body, but rather, halts that iteration and transfers control to the next iteration of the loop</td></tr>
<tr><td>6</td><td>Single Entry and Single Exit guideline</td><td>School of thought that there should only be one way to enter a loop and one way to exit; use of continue/break violates this</td></tr>
<tr><td>7</td><td>Array Declaration</td><td>Arrays are created in the same way you instantiate an object of a class, the New keyword. Syntax: type [] identifier = new type [integral value]; or when declared without instantiating, type [] identifier; used in conjunction with identifier = new type [integral value];</td></tr>
<tr><td>7</td><td>Base Type</td><td>All data values in an array must be of the same base type</td></tr>
<tr><td>7</td><td>Array length</td><td>Always one more than the last index due to zero base structure (0, 1, 2, 3..)</td></tr>
<tr><td>7</td><td>BinarySearch</td><td>System.Array method; searches a one dimensional sorted array for a value using a unary search algorithm; returns index locations or negative value if not found</td></tr>
<tr><td>7</td><td>Clear</td><td>System.Array method; sets elements in the array to zero, false or null depending on the element type</td></tr>
<tr><td>7</td><td>Clone</td><td>System.Array method; creates a copy of the array, returns an object</td></tr>
<tr><td>7</td><td>Copy</td><td>System.Array method; copies a section of one array to another array</td></tr>
<tr><td>7</td><td>CopyTo</td><td>System.Array method; copies elements of a one-dimensional array to another one-dimensional array starting at the specified destination array index (destination must be large enough to hold elements)</td></tr>
<tr><td>7</td><td>GetValue</td><td>System.Array method; gets the value of the specified element in the current array</td></tr>
<tr><td>7</td><td>IndexOf</td><td>System.Array method; returns the index of the first occurrence of a value in a one dimensional array or in a portion of the array</td></tr>
<tr><td>7</td><td>Reverse</td><td>System.Array method; reverses the order of the elements in a one dimensional array or in a portion of the array</td></tr>
<tr><td>7</td><td>SetValue</td><td>System.Array method; sets the specified element in the current array to the specified value</td></tr>
<tr><td>7</td><td>Sort</td><td>System.Array method; Sorts the elements in the one-dimensional array objects</td></tr>
<tr><td>7</td><td>Pass By Reference</td><td>The array identifier memory location does not actually contain the values, but rather an address indicating the location of elements in the array</td></tr>
<tr><td>7</td><td>Call or Pass by Value</td><td>Sends the actual data</td></tr>
<tr><td>7</td><td>Parameter Array</td><td>Used to indicate that the number of arguments to the method may vary; keyword params appears only in the formal parameter list of the method heading.</td></tr>
<tr><td>7</td><td>Parallel Arrays</td><td>Two or more arrays that have a relationship, established using the same subscript or index to the elements; ie. Player 1's name is stored in one array slot 0, and his scores in another array's 0 slot</td></tr>
<tr><td>8</td><td>Rectangular two dimension array</td><td>Visualize a table with rows and columns; spreadsheet - Syntax: type [,] identifier = new type [rows, cols];</td></tr>
<tr><td>8</td><td>Row Major Language</td><td>C# and other RMLs store data in contiguous memory locations by row; row index always specified first</td></tr>
<tr><td>8</td><td>Rank</td><td>Property that returns the number of dimensions of the array</td></tr>
<tr><td>8</td><td>GetUpperBound / GetLowBound</td><td>Returns the bounds of the array (ie 3 in a 4 index array, or 0)</td></tr>
<tr><td>8</td><td>Jagged Array</td><td>Used when the number of columns in the rows must differ; called "array of arrays." One dimensional arrays each initialized separately</td></tr>
<tr><td>8</td><td>Multidimensional Arrays</td><td>type [ , , ] identifier = new type [planes, rows, cols]</td></tr>
<tr><td>8</td><td>ArrayList Class</td><td>Facilitates creating a list like structure that can dynamically increase or decrease in length; to instantiate should add additional using statement "using System.Collections;"</td></tr>
<tr><td>8</td><td>ArrayList Members</td><td>Add, BinarySearch, Capacity, Clear, Clone, Contains, Count, GetRange, IndexOf, Insert, InsertRange, Item, LastIndexOf, Remove, RemoveAt, RemoveRange, Repeat, Reverse, Sort, ToArray, TrimToSize</td></tr>
<tr><td>8</td><td>List<> Class</td><td>Dynamic structure that can grow or shrink in size; unlike ArrayList, requires that objects are the same type when you place them in the structure</td></tr>
<tr><td>8</td><td>String Class</td><td>Used to store a collection of Unicode characters; a reference type; equality operators do a lexicographical comparison, comparing one character at a time using its Unicode representation; objects are immutable - once a string receives a value it cannot be modified, but instead, will actually create another string</td></tr>
<tr><td>8</td><td>String Members</td><td>Clone, Compare, Concat, Copy, EndsWith, Equals, Format, IndexOf, Insert, LastIndexOf, Length - Property, PadLeft, PadRight, Remove, Replace, Split, StartsWith, Substring, ToCharArray, ToLower, ToString, ToUpper, Trim, TrimEnd, TrimStart</td></tr>
<tr><td>8</td><td>Verbatim String Literal</td><td>String literals printed verbatim, ID'd by @ symbol: @"hello \t world" would print the \t not a tab</td></tr>
<tr><td>8</td><td>Collection Classes</td><td>Classes that enable you to store and retrieve various groups of objects, initialized with "using System.Collections;" - includes BitArray, Hashtable, Queue, Stack</td></tr>
<tr><td>8</td><td>BitArray</td><td>Stores a collection of bit values, represented as Booleans where true indicates the bit is on and false indicates it is off</td></tr>
<tr><td>8</td><td>Hashing</td><td>A technique used to provide security when data is transmitted across networks; message encrypted using a type of algorithm</td></tr>
<tr><td>8</td><td>Hash Function</td><td>The algorithm used to store data; with large collections of data, the key or unique entry is hashed or converted into an index for faster retrieval of data</td></tr>
<tr><td>8</td><td>Hash Table</td><td>specialized .NET class that represents a collection of key/value pars that are organized based on the hash code of the key</td></tr>
<tr><td>8</td><td>Bucket</td><td>A virtual subgroup of elements within a hashtable; bucket concept is what allows or enables multiple keys to hash to the same index</td></tr>
<tr><td>8</td><td>Queue</td><td>Similar to a real-life queue; first in line gets serviced before second; can be created using a sequential array or a linked list; First In First Out (FIFO) collection of objects; circular array</td></tr>
<tr><td>8</td><td>Queue Class</td><td>Methods include TrimToSize, Enqueue (add at end), Dequeue (remove from start), Peek (shows object at beginning of queue without removing it), Clear, Contains, Count</td></tr>
<tr><td>8</td><td>Linked List</td><td>Types of data structures that consist of a sequence of data records such that in each record there is an additional field that contains a reference to the next record in the sequence; benefit over array is that links can be updated to rearrange the linked order</td></tr>
<tr><td>8</td><td>Stack</td><td>Works like trays are stacked upon each other; Last In First Out (LIFO) collection of objects</td></tr>
<tr><td>8</td><td>Stack Methods</td><td>Push (adds an object to the end of the stack), Pop (removes/returns the object to the beginning), Peek, Clear, Contains, Count</td></tr>
</table>